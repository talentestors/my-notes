import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{ah as a,ap as e,ai as t}from"./app-CAqLFJSb.js";const p="/my-notes/assets/u2K8Y5yU1zf9LQ4-DrGN-wiM.webp",l="/my-notes/assets/QOvi5YpnaHTxrVU-D2LTTpIV.webp",i="/my-notes/assets/4nFVBxOIo6QKjHA-CZM6DxSt.webp",c="/my-notes/assets/i857GLYJ1fSIKz4-CjU1dXiY.webp",o="/my-notes/assets/tizymh9BjYAFp3x-B1UsZgsH.webp",u="/my-notes/assets/WORY4BSMzhcQNyt-2dVzI3WW.webp",r="/my-notes/assets/AbpBRLIwczTyqMP-BUvWQLKt.webp",d="/my-notes/assets/oVg2cwD4Gjrfab7-C8qykHEF.webp",k="/my-notes/assets/2hbcO5flxzodN9J-BPopNagb.webp",m="/my-notes/assets/aB8fu1GUNwYMPLh-DKZ5D6YB.webp",v="/my-notes/assets/V1RyLUTBgfFMk69-BLXDi4CG.webp",b="/my-notes/assets/28BVwcadNEjCnLi-WqowwKeR.webp",g="/my-notes/assets/3TvqOXGsDIPbzlh-DZJalsKH.webp",y="/my-notes/assets/HE7QJpfbh6sOLji-CXF5GB4x.webp",f="/my-notes/assets/lY6sJwicX5d2FVg-Gf0E_FYS.webp",w="/my-notes/assets/WskFX26NDco8Jgv-Db8PTweq.webp",h="/my-notes/assets/p6wAqsZneuI8Wo3-IqzmBcyW.webp",C="/my-notes/assets/dzmcQUyFrH9kTWZ-ClP2Dn0h.webp",x="/my-notes/assets/Phy8UoMGiLkpdsf-BuZzCnEb.webp",_="/my-notes/assets/uCrZ8aG2EoxLM5c-CbHdU5CJ.webp",j="/my-notes/assets/LOycXsCrm4vAjDk-B77bGjH8.webp",M="/my-notes/assets/O4XnFbfRShkc8WZ-DcSZ8SpT.webp",q="/my-notes/assets/zkJVicf764bFPXd-B9lY0v81.webp",S="/my-notes/assets/dPoWa74AeYJcIG1-vvIgu3r_.webp",L="/my-notes/assets/c7ebHq3TBxudK1A-BBdrC40z.webp",T="/my-notes/assets/heoLwXRVpuBYbZn-CfMg8Vfm.webp",A="/my-notes/assets/fDTVYpAlaBF6j91-yEbV0Fe6.webp",V="/my-notes/assets/1wOpRXoQklGN9Ez-BkDjxuR9.webp",J="/my-notes/assets/kOPlftdWADqyoHL-DgqusBnl.webp",B="/my-notes/assets/JyFWfPbBvIK5zMe-CEPpot0A.webp",I="/my-notes/assets/IRo9i6hntA2jQ3X-CYp3kTl1.webp",O="/my-notes/assets/UIV6fJknmM4bojP-DQaCyPyL.webp",N="/my-notes/assets/RFaE7s5CnmylgkT-CvTseP4r.webp",E={};function U(z,n){return t(),a("div",null,n[0]||(n[0]=[e('<p>前面我们讲解了 JVM 的内存结构，包括 JVM 如何对内存进行划分，如何对内存区域进行垃圾回收。接下来，我们来研究一下类文件结构以及类的加载机制。</p><h2 id="类文件结构" tabindex="-1"><a class="header-anchor" href="#类文件结构"><span>类文件结构</span></a></h2><p>在我们学习 C 语言的时候，我们的编程过程会经历如下几个阶段：写代码、保存、编译、运行。实际上，最关键的一步是编译，因为只有经历了编译之后，我们所编写的代码才能够翻译为机器可以直接运行的二进制代码，并且在不同的操作系统下，我们的代码都需要进行一次编译之后才能运行。</p><blockquote><p>如果全世界所有的计算机指令集只有 x86 一种，操作系统只有 Windows 一种，那也许就不会有 Java 语言的出现。</p></blockquote><p>随着时代的发展，人们迫切希望能够在不同的操作系统、不同的计算机架构中运行同一套编译之后的代码。本地代码不应该是我们编程的唯一选择，所以，越来越多的语言选择了与操作系统和机器指令集无关的中立格式作为编译后的存储格式。</p><p>“一次编写，到处运行”，Java 最引以为傲的口号，标志着平台不再是限制编程语言的阻碍。</p><p>实际上，Java 正式利用了这样的解决方案，将源代码编译为平台无关的中间格式，并通过对应的 Java 虚拟机读取和运行这些中间格式的编译文件，这样，我们只需要考虑不同平台的虚拟机如何编写，而 Java 语言本身很轻松地实现了跨平台。</p><p>现在，越来越多的开发语言都支持将源代码编译为<code>.class</code>字节码文件格式，以便能够直接交给 JVM 运行，包括 Kotlin（安卓开发官方指定语言）、Groovy、Scala 等。</p><figure><img src="'+p+`" alt="image-20230306165746693" tabindex="0" loading="lazy"><figcaption>image-20230306165746693</figcaption></figure><p>那么，让我们来看看，我们的源代码编译之后，是如何保存在字节码文件中的。</p><hr><h3 id="类文件信息" tabindex="-1"><a class="header-anchor" href="#类文件信息"><span>类文件信息</span></a></h3><p>我们之前都是使用<code>javap</code>命令来对字节码文件进行反编译查看的，那么，它以二进制格式是怎么保存呢？我们可以使用 WinHex 软件（Mac 平台可以使用<a href="https://www.macwk.com/soft/010-editor" target="_blank" rel="noopener noreferrer">010 Editor</a>）来以十六进制查看字节码文件。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">int</span> a <span class="token operator">=</span> i<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token operator">++</span>i<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>找到我们在 IDEA 中编译出来的 class 文件，将其拖动进去：</p><figure><img src="`+l+`" alt="image-20230306165815432" tabindex="0" loading="lazy"><figcaption>image-20230306165815432</figcaption></figure><p>可以看到整个文件中，全是一个字节一个字节分组的样子，从左上角开始，一行一行向下读取。可以看到在右侧中还出现了一些我们之前也许见过的字符串，比如&quot;&lt;init&gt;&quot;、&quot;Object&quot;等。</p><p>实际上 Class 文件采用了一种类似于 C 中结构体的伪结构来存储数据（当然我们直接看是看不出来的），但是如果像这样呢？</p><div class="language-wasm line-numbers-mode" data-highlighter="prismjs" data-ext="wasm"><pre><code class="language-wasm"><span class="line">Classfile /Users/nagocoler/Develop.localized/JavaHelloWorld/target/classes/com/test/Main.class</span>
<span class="line">  Last modified <span class="token number">2022</span><span class="token number">-2</span><span class="token number">-23</span>; size <span class="token number">444</span> bytes</span>
<span class="line">  MD5 checksum 8af3e63f57bcb5e3d0eec4b0468de35b</span>
<span class="line">  Compiled from <span class="token string">&quot;Main.java&quot;</span></span>
<span class="line">public class com.test.Main</span>
<span class="line">  minor version: <span class="token number">0</span></span>
<span class="line">  major version: <span class="token number">52</span></span>
<span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span>
<span class="line">Constant pool:</span>
<span class="line">   #<span class="token number">1</span> = Methodref          #<span class="token number">3</span>.#<span class="token number">21</span>         // java/lang/Object.<span class="token string">&quot;&lt;init&gt;&quot;</span>:<span class="token punctuation">(</span><span class="token punctuation">)</span>V</span>
<span class="line">   #<span class="token number">2</span> = Class              #<span class="token number">22</span>            // com/test/Main</span>
<span class="line">   #<span class="token number">3</span> = Class              #<span class="token number">23</span>            // java/lang/Object</span>
<span class="line">   #<span class="token number">4</span> = Utf8               &lt;init&gt;</span>
<span class="line">   #<span class="token number">5</span> = Utf8               <span class="token punctuation">(</span><span class="token punctuation">)</span>V</span>
<span class="line">   #<span class="token number">6</span> = Utf8               Code</span>
<span class="line">   #<span class="token number">7</span> = Utf8               LineNumberTable</span>
<span class="line">   #<span class="token number">8</span> = Utf8               LocalVariableTable</span>
<span class="line">   #<span class="token number">9</span> = Utf8               this</span>
<span class="line">  #<span class="token number">10</span> = Utf8               Lcom/test/Main;</span>
<span class="line">  #<span class="token number">11</span> = Utf8               main</span>
<span class="line">  #<span class="token number">12</span> = Utf8               <span class="token punctuation">(</span>[Ljava/lang/String;<span class="token punctuation">)</span>V</span>
<span class="line">  #<span class="token number">13</span> = Utf8               args</span>
<span class="line">  #<span class="token number">14</span> = Utf8               [Ljava/lang/String;</span>
<span class="line">  #<span class="token number">15</span> = Utf8               i</span>
<span class="line">  #<span class="token number">16</span> = Utf8               I</span>
<span class="line">  #<span class="token number">17</span> = Utf8               a</span>
<span class="line">  #<span class="token number">18</span> = Utf8               b</span>
<span class="line">  #<span class="token number">19</span> = Utf8               SourceFile</span>
<span class="line">  #<span class="token number">20</span> = Utf8               Main.java</span>
<span class="line">  #<span class="token number">21</span> = NameAndType        #<span class="token number">4</span>:#<span class="token number">5</span>          // <span class="token string">&quot;&lt;init&gt;&quot;</span>:<span class="token punctuation">(</span><span class="token punctuation">)</span>V</span>
<span class="line">  #<span class="token number">22</span> = Utf8               com/test/Main</span>
<span class="line">  #<span class="token number">23</span> = Utf8               java/lang/Object</span>
<span class="line">{</span>
<span class="line">  public com.test.Main<span class="token punctuation">(</span><span class="token punctuation">)</span>;</span>
<span class="line">    descriptor: <span class="token punctuation">(</span><span class="token punctuation">)</span>V</span>
<span class="line">    flags: ACC_PUBLIC</span>
<span class="line">    Code:</span>
<span class="line">      stack=<span class="token number">1</span>, locals=<span class="token number">1</span>, args_size=<span class="token number">1</span></span>
<span class="line">         <span class="token number">0</span>: aload_0</span>
<span class="line">         <span class="token number">1</span>: invokespecial #<span class="token number">1</span>                  // Method java/lang/Object.<span class="token string">&quot;&lt;init&gt;&quot;</span>:<span class="token punctuation">(</span><span class="token punctuation">)</span>V</span>
<span class="line">         <span class="token number">4</span>: <span class="token keyword">return</span></span>
<span class="line">      LineNumberTable:</span>
<span class="line">        line <span class="token number">11</span>: <span class="token number">0</span></span>
<span class="line">      LocalVariableTable:</span>
<span class="line">        Start  Length  Slot  Name   Signature</span>
<span class="line">            <span class="token number">0</span>       <span class="token number">5</span>     <span class="token number">0</span>  this   Lcom/test/Main;</span>
<span class="line"></span>
<span class="line">  public static void main<span class="token punctuation">(</span>java.lang.String[]<span class="token punctuation">)</span>;</span>
<span class="line">    descriptor: <span class="token punctuation">(</span>[Ljava/lang/String;<span class="token punctuation">)</span>V</span>
<span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span>
<span class="line">    Code:</span>
<span class="line">      stack=<span class="token number">1</span>, locals=<span class="token number">4</span>, args_size=<span class="token number">1</span></span>
<span class="line">         <span class="token number">0</span>: bipush        <span class="token number">10</span></span>
<span class="line">         <span class="token number">2</span>: istore_1</span>
<span class="line">         <span class="token number">3</span>: iload_1</span>
<span class="line">         <span class="token number">4</span>: iinc          <span class="token number">1</span>, <span class="token number">1</span></span>
<span class="line">         <span class="token number">7</span>: istore_2</span>
<span class="line">         <span class="token number">8</span>: iinc          <span class="token number">1</span>, <span class="token number">1</span></span>
<span class="line">        <span class="token number">11</span>: iload_1</span>
<span class="line">        <span class="token number">12</span>: istore_3</span>
<span class="line">        <span class="token number">13</span>: <span class="token keyword">return</span></span>
<span class="line">      LineNumberTable:</span>
<span class="line">        line <span class="token number">13</span>: <span class="token number">0</span></span>
<span class="line">        line <span class="token number">14</span>: <span class="token number">3</span></span>
<span class="line">        line <span class="token number">15</span>: <span class="token number">8</span></span>
<span class="line">        line <span class="token number">16</span>: <span class="token number">13</span></span>
<span class="line">      LocalVariableTable:</span>
<span class="line">        Start  Length  Slot  Name   Signature</span>
<span class="line">            <span class="token number">0</span>      <span class="token number">14</span>     <span class="token number">0</span>  args   [Ljava/lang/String;</span>
<span class="line">            <span class="token number">3</span>      <span class="token number">11</span>     <span class="token number">1</span>     i   I</span>
<span class="line">            <span class="token number">8</span>       <span class="token number">6</span>     <span class="token number">2</span>     a   I</span>
<span class="line">           <span class="token number">13</span>       <span class="token number">1</span>     <span class="token number">3</span>     b   I</span>
<span class="line">}</span>
<span class="line">SourceFile: <span class="token string">&quot;Main.java&quot;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>乍一看，是不是感觉还真的有点结构体那味？</p><p>而结构体中，有两种允许存在的数据类型，一个是无符号数，还有一个是表。</p><ul><li>无符号数一般是基本数据类型，用 u1、u2、u4、u8 来表示，表示 1 个字节~8 个字节的无符号数。可以表示数字、索引引用、数量值或是以 UTF-8 编码格式的字符串。</li><li>表包含多个无符号数，并且以&quot;_info&quot;结尾。</li></ul><p>我们首先从最简的开始看起。</p><figure><img src="`+i+'" alt="image-20230306165846303" tabindex="0" loading="lazy"><figcaption>image-20230306165846303</figcaption></figure><p>首先，我们可以看到，前 4 个字节（共 32 位）组成了魔数（其实就是表示这个文件是一个 JVM 可以运行的字节码文件，除了 Java 以外，其他某些文件中也采用了这种魔数机制来进行区分，这种方式比直接起个文件扩展名更安全）</p><p>字节码文件的魔数为：CAFEBABE（这名字能想出来也是挺难的了，毕竟 4 个 bit 位只能表示出 A-F 这几个字母）</p><p>紧接着魔数的后面 4 个字节存储的是字节码文件的版本号，注意前两个是次要版本号（现在基本都不用了，都是直接 Java8、Java9 这样命名了），后面两个是主要版本号，这里我们主要看主版本号，比如上面的就是 34，注意这是以 16 进制表示的，我们把它换算为 10 进制后，得到的结果为：<code>34 -&gt; 3*16 + 4 = 52</code>，其中<code>52</code>代表的是<code>JDK8</code>编译的字节码文件（51 是 JDK7、50 是 JDK6、53 是 JDK9，以此类推）</p><p>JVM 会根据版本号决定是否能够运行，比如 JDK6 只能支持版本号为 1.1~6 的版本，也就是说必须是 Java6 之前的环境编译出来的字节码文件，否则无法运行。又比如我们现在安装的是 JDK8 版本，它能够支持的版本号为 1.1~8，那么如果这时我们有一个通过 Java7 编译出来的字节码文件，依然是可以运行的，所以说 Java 版本是向下兼容的。</p><p>紧接着，就是类的常量池了，这里面存放了类中所有的常量信息（注意这里的常量并不是指我们手动创建的 final 类型常量，而是程序运行一些需要用到的常量数据，比如字面量和符号引用等）由于常量的数量不是确定的，所以在最开始的位置会存放常量池中常量的数量（是从 1 开始计算的，不是 0，比如这里是 18，翻译为 10 进制就是 24，所以实际上有 23 个常量）</p><p>接着再往下，就是常量池里面的数据了，每一项常量池里面的数据都是一个表，我们可以看到他们都是以_info 结尾的：</p><figure><img src="'+c+'" alt="image-20230306165906177" tabindex="0" loading="lazy"><figcaption>image-20230306165906177</figcaption></figure><p>我们来看看一个表中定义了哪些内容：</p><figure><img src="'+o+'" alt="image-20230306165923282" tabindex="0" loading="lazy"><figcaption>image-20230306165923282</figcaption></figure><p>首先上来就会有一个 1 字节的无符号数，它用于表示当前常量的类型（常量类型有很多个）这里只列举一部分的类型介绍：</p><table><thead><tr><th style="text-align:center;">类型</th><th style="text-align:center;">标志</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">CONSTANT_Utf8_info</td><td style="text-align:center;">1</td><td style="text-align:center;">UTF-8 编码格式的字符串</td></tr><tr><td style="text-align:center;">CONSTANT_Integer_info</td><td style="text-align:center;">3</td><td style="text-align:center;">整形字面量（第一章我们演示的很大的数字，实际上就是以字面量存储在常量池中的）</td></tr><tr><td style="text-align:center;">CONSTANT_Class_info</td><td style="text-align:center;">7</td><td style="text-align:center;">类或接口的符号引用</td></tr><tr><td style="text-align:center;">CONSTANT_String_info</td><td style="text-align:center;">8</td><td style="text-align:center;">字符串类型的字面量</td></tr><tr><td style="text-align:center;">CONSTANT_Fieldref_info</td><td style="text-align:center;">9</td><td style="text-align:center;">字段的符号引用</td></tr><tr><td style="text-align:center;">CONSTANT_Methodref_info</td><td style="text-align:center;">10</td><td style="text-align:center;">方法的符号引用</td></tr><tr><td style="text-align:center;">CONSTANT_MethodType_info</td><td style="text-align:center;">16</td><td style="text-align:center;">方法类型</td></tr><tr><td style="text-align:center;">CONSTANT_NameAndType_info</td><td style="text-align:center;">12</td><td style="text-align:center;">字段或方法的部分符号引用</td></tr></tbody></table><p>实际上这些东西，虽然我们不知道符号引用是什么东西，我们可以观察出来，这些东西或多或少都是存放类中一些名称、数据之类的东西。</p><p>比如我们来看第一个<code>CONSTANT_Methodref_info</code>表中存放了什么数据，这里我只列出它的结构表（详细的结构表可以查阅《深入理解 Java 虚拟机 第三版》中 222 页总表）：</p><table><thead><tr><th style="text-align:center;">常量</th><th style="text-align:center;">项目</th><th style="text-align:center;">类型</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">CONSTANT_Methodref_info</td><td style="text-align:center;">tag</td><td style="text-align:center;">u1</td><td style="text-align:center;">值为 10</td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;">index</td><td style="text-align:center;">u2</td><td style="text-align:center;">指向声明方法的类描述父 CONSTANT_Class_info 索引项</td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;">index</td><td style="text-align:center;">u2</td><td style="text-align:center;">指向名称及类型描述符 CONSTANT_NameAndType_info 索引项</td></tr></tbody></table><p>比如我们刚刚的例子中：</p><figure><img src="'+u+'" alt="image-20230306165936467" tabindex="0" loading="lazy"><figcaption>image-20230306165936467</figcaption></figure><p>可以看到，第一个索引项指向了第 3 号常量，我们来看看三号常量：</p><figure><img src="'+r+'" alt="image-20230306165947568" tabindex="0" loading="lazy"><figcaption>image-20230306165947568</figcaption></figure><table><thead><tr><th style="text-align:center;">常量</th><th style="text-align:center;">项目</th><th style="text-align:center;">类型</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">CONSTANT_Class_info</td><td style="text-align:center;">tag</td><td style="text-align:center;">u1</td><td style="text-align:center;">值为 7</td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;">index</td><td style="text-align:center;">u2</td><td style="text-align:center;">指向全限定名常量项的索引</td></tr></tbody></table><p>那么我们接着来看 23 号常量又写的啥：</p><figure><img src="'+d+'" alt="image-20230306170009857" tabindex="0" loading="lazy"><figcaption>image-20230306170009857</figcaption></figure><p>可以看到指向的 UTF-8 字符串值为<code>java/lang/Object</code>这下搞明白了，首先这个方法是由 Object 类定义的，那么接着我们来看第二项 u2 <code>name_and_type_index</code>，指向了 21 号常量，也就是字段或方法的部分符号引用：</p><figure><img src="'+k+'" alt="image-20230306170021693" tabindex="0" loading="lazy"><figcaption>image-20230306170021693</figcaption></figure><table><thead><tr><th style="text-align:center;">常量</th><th style="text-align:center;">项目</th><th style="text-align:center;">类型</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">CONSTANT_NameAndType_info</td><td style="text-align:center;">tag</td><td style="text-align:center;">u1</td><td style="text-align:center;">值为 12</td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;">index</td><td style="text-align:center;">u2</td><td style="text-align:center;">指向字段或方法名称常量项的索引</td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;">index</td><td style="text-align:center;">u2</td><td style="text-align:center;">指向字段或方法描述符常量项的索引</td></tr></tbody></table><p>其中第一个索引就是方法的名称，而第二个就是方法的描述符，描述符明确了方法的参数以及返回值类型，我们分别来看看 4 号和 5 号常量：</p><figure><img src="'+m+'" alt="image-20230306170037268" tabindex="0" loading="lazy"><figcaption>image-20230306170037268</figcaption></figure><p>可以看到，方法名称为&quot;&lt;init&gt;&quot;，一般构造方法的名称都是&lt;init&gt;，普通方法名称是什么就是什么，方法描述符为&quot;()V&quot;，表示此方法没有任何参数，并且返回值类型为 void，描述符对照表如下：</p><figure><img src="'+v+`" alt="image-20230306170051403" tabindex="0" loading="lazy"><figcaption>image-20230306170051403</figcaption></figure><p>比如这里有一个方法<code>public int test(double a, char c){ ... }</code>，那么它的描述符就应该是：<code>(DC)I</code>，参数依次放入括号中，括号右边是返回值类型。再比如<code>public String test(Object obj){ ... }</code>，那么它的描述符就应该是：<code>(Ljava/lang/Object;)Ljava/lang/String</code>，注意如果参数是对象类型，那么必须在后面添加<code>;</code></p><p>对于数组类型，只需要在类型最前面加上<code>[</code>即可，有几个维度，就加几个，比如<code>public void test(int[][] arr)</code>，参数是一个二维 int 类型数组，那么它的描述符为：<code>([[I)V</code></p><p>所以，这里表示的，实际上就是此方法是一个无参构造方法，并且是属于 Object 类的。那么，为什么这里需要 Object 类构造方法的符号引用呢？还记得我们在 JavaSE 中说到的，每个类都是直接或间接继承自 Object 类，所有类的构造方法，必须先调用父类的构造方法，但是如果父类存在无参构造，默认可以不用显示调用<code>super</code>关键字（当然本质上是调用了的）。</p><p>所以说，当前类因为没有继承自任何其他类，那么就默认继承的 Object 类，所以，在当前类的默认构造方法中，调用了父类 Object 类的无参构造方法，因此这里需要符号引用的用途显而易见，就是因为需要调用 Object 类的无参构造方法。</p><p>我们可以在反编译结果中的方法中看到：</p><div class="language-wasm line-numbers-mode" data-highlighter="prismjs" data-ext="wasm"><pre><code class="language-wasm"><span class="line">public com.test.Main<span class="token punctuation">(</span><span class="token punctuation">)</span>;</span>
<span class="line">    descriptor: <span class="token punctuation">(</span><span class="token punctuation">)</span>V</span>
<span class="line">    flags: ACC_PUBLIC</span>
<span class="line">    Code:</span>
<span class="line">      stack=<span class="token number">1</span>, locals=<span class="token number">1</span>, args_size=<span class="token number">1</span></span>
<span class="line">         <span class="token number">0</span>: aload_0</span>
<span class="line">         <span class="token number">1</span>: invokespecial #<span class="token number">1</span>                  // Method java/lang/Object.<span class="token string">&quot;&lt;init&gt;&quot;</span>:<span class="token punctuation">(</span><span class="token punctuation">)</span>V</span>
<span class="line">         <span class="token number">4</span>: <span class="token keyword">return</span></span>
<span class="line">      LineNumberTable:</span>
<span class="line">        line <span class="token number">11</span>: <span class="token number">0</span></span>
<span class="line">      LocalVariableTable:</span>
<span class="line">        Start  Length  Slot  Name   Signature</span>
<span class="line">            <span class="token number">0</span>       <span class="token number">5</span>     <span class="token number">0</span>  this   Lcom/test/Main;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>invokespecial</code>（调用父类构造方法）指令的参数指向了 1 号常量，而 1 号常量正是代表的 Object 类的无参构造方法，虽然饶了这么大一圈，但是过程理清楚，还是很简单的。</p><p>虽然我们可以直接查看 16 进制的结果，但是还是不够方便，但是我们也不能每次都去使用<code>javap</code>命令，所以我们这里安装一个 IDEA 插件，来方便我们查看字节码中的信息，名称为<code>jclasslib Bytecode Viewer</code> ：</p><figure><img src="`+b+'" alt="image-20230306170130977" tabindex="0" loading="lazy"><figcaption>image-20230306170130977</figcaption></figure><p>安装完成后，我们可以在我们的 IDEA 右侧看到它的板块，但是还没任何数据，那么比如现在我们想要查看 Main 类的字节码文件时，可以这样操作：</p><figure><img src="'+g+'" alt="image-20230306170141372" tabindex="0" loading="lazy"><figcaption>image-20230306170141372</figcaption></figure><p>首先在项目中选中我们的 Main 类，然后点击工具栏的视图，然后点击<code>Show Bytecode With Jclasslib</code>，这样右侧就会出现当前类的字节码解析信息了。注意如果修改了类的话，那么需要你点击运行或是构建，然后点击刷新按钮来进行更新。</p><p>接着我们来看下一个内容，在常量池之后，紧接着就是访问标志，访问标志就是类的种类以及类上添加的一些关键字等内容：</p><figure><img src="'+y+'" alt="image-20230306170153604" tabindex="0" loading="lazy"><figcaption>image-20230306170153604</figcaption></figure><p>可以看到它只占了 2 个字节，那么它是如何表示访问标志呢?</p><figure><img src="'+f+'" alt="image-20230306170207034" tabindex="0" loading="lazy"><figcaption>image-20230306170207034</figcaption></figure><p>比如我们这里的 Main 类，它是一个普通的 class 类型，并且访问权限为 public，那么它的访问标志值是这样计算的：</p><p><code>ACC_PUBLIC | ACC_SUPER = 0x0001 | 0x0020 = 0x0021</code>（这里进行的是按位或运算），可以看到和我们上面的结果是一致的。</p><p>再往下就是类索引、父类索引、接口索引：</p><figure><img src="'+w+'" alt="image-20230306170218340" tabindex="0" loading="lazy"><figcaption>image-20230306170218340</figcaption></figure><p>可以看到它们的值也是指向常量池中的值，其中 2 号常量正是存储的当前类信息，3 号常量存储的是父类信息，这里就不再倒推回去了，由于没有接口，所以这里接口数量为 0，如果不为 0 还会有一个索引表来引用接口。</p><p>接着就是字段和方法表集合了：</p><figure><img src="'+h+`" alt="image-20230306170228985" tabindex="0" loading="lazy"><figcaption>image-20230306170228985</figcaption></figure><p>由于我们这里没有声明任何字段，所以我们先给 Main 类添加一个字段再重新加载一下：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">int</span> a <span class="token operator">=</span> i<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token operator">++</span>i<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+C+'" alt="image-20230306170307227" tabindex="0" loading="lazy"><figcaption>image-20230306170307227</figcaption></figure><p>现在字节码就新增了一个字段表，这个字段表实际上就是我们刚刚添加的成员字段<code>a</code>的数据。</p><p>可以看到一共有四个 2 字节的数据：</p><figure><img src="'+x+'" alt="image-20230306170316904" tabindex="0" loading="lazy"><figcaption>image-20230306170316904</figcaption></figure><p>首先是<code>access_flags</code>，这个与上面类标志的计算规则是一样的，表还是先列出来吧：</p><figure><img src="'+_+'" alt="image-20230306170332081" tabindex="0" loading="lazy"><figcaption>image-20230306170332081</figcaption></figure><p>第二个数据<code>name_index</code>表示字段的名称常量，这里指向的是 5 号常量，那么我们来看看 5 号常量是不是字段名称：</p><figure><img src="'+j+'" alt="image-20230306170345473" tabindex="0" loading="lazy"><figcaption>image-20230306170345473</figcaption></figure><p>没问题，这里就是<code>a</code>,下一个是<code>descirptor_index</code>，存放的是描述符，不过这里因为不是方法而是变量，所以描述符直接写对应类型的标识字符即可，比如这里是<code>int</code>类型，那么就是<code>I</code>。</p><p>最后，<code>attrbutes_count</code>属性计数器，用于描述一些额外信息，这里我们暂时不做介绍。</p><p>接着就是我们的方法表了：</p><figure><img src="'+M+'" alt="image-20230306170359554" tabindex="0" loading="lazy"><figcaption>image-20230306170359554</figcaption></figure><p>可以看到方法表中一共有三个方法，其中第一个方法我们刚刚已经介绍过了，它的方法名称为<code>&lt;init&gt;</code>，表示它是一个构造方法，我们看到最后一个方法名称为<code>&lt;clinit&gt;</code>，这个是类在初始化时会调用的方法（是隐式的，自动生成的），它主要是用于静态变量初始化语句和静态块的执行，因为我们这里给静态成员变量 a 赋值为 10，所以会在一开始为其赋值：</p><figure><img src="'+q+'" alt="image-20230306170411225" tabindex="0" loading="lazy"><figcaption>image-20230306170411225</figcaption></figure><p>而第二个方法，就是我们的<code>main</code>方法了，但是现在我们先不急着去看它的详细实现过程，我们来看看它的属性表。</p><p>属性表实际上类中、字段中、方法中都可以携带自己的属性表，属性表存放的正是我们的代码、本地变量等数据，比如 main 方法就存在 4 个本地变量，那么它的本地变量存放在哪里呢：</p><figure><img src="'+S+'" alt="image-20230306170426154" tabindex="0" loading="lazy"><figcaption>image-20230306170426154</figcaption></figure><p>可以看到，属性信息呈现套娃状态，在此方法中的属性包括了一个 Code 属性，此属性正是我们的 Java 代码编译之后变成字节码指令，然后存放的地方，而在此属性中，又嵌套了本地变量表和源码行号表。</p><p>可以看到 code 中存放的就是所有的字节码指令：</p><figure><img src="'+L+'" alt="image-20230306170436483" tabindex="0" loading="lazy"><figcaption>image-20230306170436483</figcaption></figure><p>这里我们暂时不对字节码指令进行讲解（其实也用不着讲了，都认识的差不多了）。我们接着来看本地变量表，这里存放了我们方法中要用到的局部变量：</p><figure><img src="'+T+'" alt="image-20230306170452941" tabindex="0" loading="lazy"><figcaption>image-20230306170452941</figcaption></figure><p>可以看到一共有四个本地变量，而第一个变量正是 main 方法的形参<code>String[] args</code>，并且表中存放了本地变量的长度、名称、描述符等内容。当然，除了我们刚刚认识的这几个属性之外，完整属性可以查阅《深入理解 Java 虚拟机 第三版》231 页。</p><p>最后，类也有一些属性：</p><figure><img src="'+A+`" alt="image-20230306170510722" tabindex="0" loading="lazy"><figcaption>image-20230306170510722</figcaption></figure><p>此属性记录的是源文件名称。</p><p>这样，我们对一个字节码文件的认识差不多就结束了，在了解了字节码文件的结构之后，是不是感觉豁然开朗？</p><hr><h3 id="字节码指令" tabindex="-1"><a class="header-anchor" href="#字节码指令"><span>字节码指令</span></a></h3><p>虚拟机的指令是由一个字节长度的、代表某种特定操作含义的数字（操作码，类似于机器语言），操作后面也可以携带 0 个或多个参数一起执行。我们前面已经介绍过了，JVM 实际上并不是面向寄存器架构的，而是面向操作数栈，所以大多数指令都是不带参数的。</p><p>由于之前已经讲解过大致运行流程，这里我们就以当前的 Main 类中的 main 方法作为教材进行讲解：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">int</span> a <span class="token operator">=</span> i<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token operator">++</span>i<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，main 方法中首先是定义了一个 int 类型的变量 i，并赋值为 10，然后变量 a 接收<code>i++</code>的值，变量 b 接收<code>++i</code>的值。</p><p>那么我们来看看编译成字节码之后，是什么样的：</p><figure><img src="`+V+'" alt="image-20230306170531318" tabindex="0" loading="lazy"><figcaption>image-20230306170531318</figcaption></figure><ul><li>首先第一句，<code>bipush</code>，将 10 送至操作数栈顶。</li><li>接下来将操作数栈顶的数值存进 1 号本地变量，也就是变量 i 中。</li><li>接着将变量 i 中的值又丢向操作数栈顶</li><li>这里使用<code>iinc</code>指令，将 1 号本地变量的值增加 1（结束之后 i 的值就是 11 了）</li><li>接着将操作数栈顶的值（操作数栈顶的值是 10）存入 2 号本地变量（这下彻底知道 i++到底干了啥才会先返回后自增了吧，从原理角度来说，实际上 i 是先自增了的，但由于这里取的是操作数栈中的值，所以说就得到了 i 之前的值）</li><li>接着往下，我们看到++i 是先直接将 i 的值自增 1</li><li>然后在将其值推向操作数栈顶</li></ul><figure><img src="'+J+`" alt="image-20230306170553756" tabindex="0" loading="lazy"><figcaption>image-20230306170553756</figcaption></figure><p>而从结果来看，<code>i++</code>操作确实是先返回再自增的，而字节码指令层面来说，却是截然相反的，只是结果一致罢了。</p><hr><h3 id="asm-字节码编程" tabindex="-1"><a class="header-anchor" href="#asm-字节码编程"><span>ASM 字节码编程</span></a></h3><p>既然字节码文件结构如此清晰，那么我们能否通过编程，来直接创建一个字节码文件呢？如果我们可以直接编写一个字节码文件，那么我们就可以省去编译的过程。ASM（某些 JDK 中内置）框架正是用于支持字节码编程的框架。</p><p>比如现在我们需要创建一个普通的 Main 类（暂时不写任何内容）</p><p>首先我们来看看如何通过编程创建一个 Main 类的字节码文件：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">ClassWriter</span> writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassWriter</span><span class="token punctuation">(</span><span class="token class-name">ClassWriter</span><span class="token punctuation">.</span><span class="token constant">COMPUTE_MAXS</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先需要获取<code>ClassWriter</code>对象，我们可以使用它来编辑类的字节码文件，在构造时需要传入参数：</p><ul><li>0 这种方式不会自动计算操作数栈和局部临时变量表大小，需要自己手动来指定</li><li>ClassWriter.COMPUTE_MAXS(1) 这种方式会自动计算上述操作数栈和局部临时变量表大小，但需要手动触发。</li><li>ClassWriter.COMPUTE_FRAMES(2) 这种方式不仅会计算上述操作数栈和局部临时变量表大小，而且会自动计算 StackMapFrames</li></ul><p>这里我们使用<code>ClassWriter.COMPUTE_MAXS</code>即可。</p><p>接着我们首先需要指定类的一些基本信息：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">ClassWriter</span> writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassWriter</span><span class="token punctuation">(</span><span class="token class-name">ClassWriter</span><span class="token punctuation">.</span><span class="token constant">COMPUTE_MAXS</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">//因为这里用到的常量比较多，所以说直接一次性静态导入：import static jdk.internal.org.objectweb.asm.Opcodes.*;</span></span>
<span class="line">        writer<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token constant">V1_8</span><span class="token punctuation">,</span> <span class="token constant">ACC_PUBLIC</span><span class="token punctuation">,</span><span class="token string">&quot;com/test/Main&quot;</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">&quot;java/lang/Object&quot;</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们将字节码文件的版本设定位 Java8，然后修饰符设定为<code>ACC_PUBLIC</code>代表<code>public class Main</code>，类名称注意要携带包名，标签设置为<code>null</code>，父类设定为 Object 类，然后没有实现任何接口，所以说最后一个参数也是<code>null</code>。</p><p>接着，一个简答的类字节码文件就创建好了，我们可以尝试将其进行保存：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">ClassWriter</span> writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassWriter</span><span class="token punctuation">(</span><span class="token class-name">ClassWriter</span><span class="token punctuation">.</span><span class="token constant">COMPUTE_MAXS</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        writer<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token constant">V1_8</span><span class="token punctuation">,</span> <span class="token constant">ACC_PUBLIC</span><span class="token punctuation">,</span><span class="token string">&quot;com/test/Main&quot;</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">&quot;java/lang/Object&quot;</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">//调用visitEnd表示结束编辑</span></span>
<span class="line">        writer<span class="token punctuation">.</span><span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">try</span><span class="token punctuation">(</span><span class="token class-name">FileOutputStream</span> stream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">&quot;./Main.class&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">            stream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>writer<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//直接通过ClassWriter将字节码文件转换为byte数组，并保存到根目录下</span></span>
<span class="line">        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，在 IDEA 中反编译的结果为：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>test</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们知道，正常的类在编译之后，如果没有手动添加构造方法，那么会自带一个无参构造，但是我们这个类中还没有，所以我们来手动添加一个无参构造方法：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token comment">//通过visitMethod方法可以添加一个新的方法</span></span>
<span class="line">writer<span class="token punctuation">.</span><span class="token function">visitMethod</span><span class="token punctuation">(</span><span class="token constant">ACC_PUBLIC</span><span class="token punctuation">,</span> <span class="token string">&quot;&lt;init&gt;&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;()V&quot;</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到反编译的结果中已经存在了我们的构造方法：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>test</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是这样是不合法的，因为我们的构造方法还没有添加父类构造方法调用，所以说我们还需要在方法中添加父类构造方法调用指令：</p><div class="language-wasm line-numbers-mode" data-highlighter="prismjs" data-ext="wasm"><pre><code class="language-wasm"><span class="line">public com.test.Main<span class="token punctuation">(</span><span class="token punctuation">)</span>;</span>
<span class="line">    descriptor: <span class="token punctuation">(</span><span class="token punctuation">)</span>V</span>
<span class="line">    flags: ACC_PUBLIC</span>
<span class="line">    Code:</span>
<span class="line">      stack=<span class="token number">1</span>, locals=<span class="token number">1</span>, args_size=<span class="token number">1</span></span>
<span class="line">         <span class="token number">0</span>: aload_0</span>
<span class="line">         <span class="token number">1</span>: invokespecial #<span class="token number">1</span>                  // Method java/lang/Object.<span class="token string">&quot;&lt;init&gt;&quot;</span>:<span class="token punctuation">(</span><span class="token punctuation">)</span>V</span>
<span class="line">         <span class="token number">4</span>: <span class="token keyword">return</span></span>
<span class="line">      LineNumberTable:</span>
<span class="line">        line <span class="token number">11</span>: <span class="token number">0</span></span>
<span class="line">      LocalVariableTable:</span>
<span class="line">        Start  Length  Slot  Name   Signature</span>
<span class="line">            <span class="token number">0</span>       <span class="token number">5</span>     <span class="token number">0</span>  this   Lcom/test/Main;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们需要对方法进行详细编辑：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token comment">//通过MethodVisitor接收返回值，进行进一步操作</span></span>
<span class="line"><span class="token class-name">MethodVisitor</span> visitor <span class="token operator">=</span> writer<span class="token punctuation">.</span><span class="token function">visitMethod</span><span class="token punctuation">(</span><span class="token constant">ACC_PUBLIC</span><span class="token punctuation">,</span> <span class="token string">&quot;&lt;init&gt;&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;()V&quot;</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">//开始编辑代码</span></span>
<span class="line">visitor<span class="token punctuation">.</span><span class="token function">visitCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">//Label用于存储行号</span></span>
<span class="line"><span class="token class-name">Label</span> l1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Label</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">//当前代码写到哪行了，l1得到的就是多少行</span></span>
<span class="line">visitor<span class="token punctuation">.</span><span class="token function">visitLabel</span><span class="token punctuation">(</span>l1<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">//添加源码行数对应表（其实可以不用）</span></span>
<span class="line">visitor<span class="token punctuation">.</span><span class="token function">visitLineNumber</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> l1<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">//注意不同类型的指令需要用不同方法来调用，因为操作数不一致，具体的注释有写</span></span>
<span class="line">visitor<span class="token punctuation">.</span><span class="token function">visitVarInsn</span><span class="token punctuation">(</span><span class="token constant">ALOAD</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">visitor<span class="token punctuation">.</span><span class="token function">visitMethodInsn</span><span class="token punctuation">(</span><span class="token constant">INVOKESPECIAL</span><span class="token punctuation">,</span> <span class="token string">&quot;java/lang/Object&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;&lt;init&gt;&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;()V&quot;</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">visitor<span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token constant">RETURN</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token class-name">Label</span> l2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Label</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">visitor<span class="token punctuation">.</span><span class="token function">visitLabel</span><span class="token punctuation">(</span>l2<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">//添加本地变量表，这里加的是this关键字，但是方法中没用到，其实可以不加</span></span>
<span class="line">visitor<span class="token punctuation">.</span><span class="token function">visitLocalVariable</span><span class="token punctuation">(</span><span class="token string">&quot;this&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Lcom/test/Main;&quot;</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> l1<span class="token punctuation">,</span> l2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">//最后设定最大栈深度和本地变量数</span></span>
<span class="line">visitor<span class="token punctuation">.</span><span class="token function">visitMaxs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">//结束编辑</span></span>
<span class="line">visitor<span class="token punctuation">.</span><span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以对编写好的 class 文件进行反编译，看看是不是和 IDEA 编译之后的结果差不多：</p><div class="language-wasm line-numbers-mode" data-highlighter="prismjs" data-ext="wasm"><pre><code class="language-wasm"><span class="line">{</span>
<span class="line">  public com.test.Main<span class="token punctuation">(</span><span class="token punctuation">)</span>;</span>
<span class="line">    descriptor: <span class="token punctuation">(</span><span class="token punctuation">)</span>V</span>
<span class="line">    flags: ACC_PUBLIC</span>
<span class="line">    Code:</span>
<span class="line">      stack=<span class="token number">1</span>, locals=<span class="token number">1</span>, args_size=<span class="token number">1</span></span>
<span class="line">         <span class="token number">0</span>: aload_0</span>
<span class="line">         <span class="token number">1</span>: invokespecial #<span class="token number">8</span>                  // Method java/lang/Object.<span class="token string">&quot;&lt;init&gt;&quot;</span>:<span class="token punctuation">(</span><span class="token punctuation">)</span>V</span>
<span class="line">         <span class="token number">4</span>: <span class="token keyword">return</span></span>
<span class="line">      LocalVariableTable:</span>
<span class="line">        Start  Length  Slot  Name   Signature</span>
<span class="line">            <span class="token number">0</span>       <span class="token number">5</span>     <span class="token number">0</span>  this   Lcom/test/Main</span>
<span class="line">      LineNumberTable:</span>
<span class="line">        line <span class="token number">11</span>: <span class="token number">0</span></span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到和之前的基本一致了，到此为止我们构造方法就编写完成了，接着我们来写一下 main 方法，一会我们就可以通过 main 方法来运行 Java 程序了。比如我们要编写这样一个程序：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看起来很简单的一个程序对吧，但是我们如果手动去组装指令，会极其麻烦！首先 main 方法是一个静态方法，并且方法是 public 权限，然后还有一个参数<code>String[] args</code>，所以说我们这里要写的内容有点小多：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token comment">//开始安排main方法</span></span>
<span class="line"><span class="token class-name">MethodVisitor</span> v2 <span class="token operator">=</span> writer<span class="token punctuation">.</span><span class="token function">visitMethod</span><span class="token punctuation">(</span><span class="token constant">ACC_PUBLIC</span> <span class="token operator">|</span> <span class="token constant">ACC_STATIC</span><span class="token punctuation">,</span> <span class="token string">&quot;main&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;([Ljava/lang/String;)V&quot;</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">v2<span class="token punctuation">.</span><span class="token function">visitCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">//记录起始行信息</span></span>
<span class="line"><span class="token class-name">Label</span> l3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Label</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">v2<span class="token punctuation">.</span><span class="token function">visitLabel</span><span class="token punctuation">(</span>l3<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">v2<span class="token punctuation">.</span><span class="token function">visitLineNumber</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">,</span> l3<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">//首先是int a = 10的操作，执行指令依次为：</span></span>
<span class="line"><span class="token comment">// bipush 10     将10推向操作数栈顶</span></span>
<span class="line"><span class="token comment">// istore_1      将操作数栈顶元素保存到1号本地变量a中</span></span>
<span class="line">v2<span class="token punctuation">.</span><span class="token function">visitIntInsn</span><span class="token punctuation">(</span><span class="token constant">BIPUSH</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">v2<span class="token punctuation">.</span><span class="token function">visitVarInsn</span><span class="token punctuation">(</span><span class="token constant">ISTORE</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">Label</span> l4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Label</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">v2<span class="token punctuation">.</span><span class="token function">visitLabel</span><span class="token punctuation">(</span>l4<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">//记录一下行信息</span></span>
<span class="line">v2<span class="token punctuation">.</span><span class="token function">visitLineNumber</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">,</span> l4<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">//这里是获取System类中的out静态变量（PrintStream接口），用于打印</span></span>
<span class="line">v2<span class="token punctuation">.</span><span class="token function">visitFieldInsn</span><span class="token punctuation">(</span><span class="token constant">GETSTATIC</span><span class="token punctuation">,</span> <span class="token string">&quot;java/lang/System&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;out&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Ljava/io/PrintStream;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">//把a的值取出来</span></span>
<span class="line">v2<span class="token punctuation">.</span><span class="token function">visitVarInsn</span><span class="token punctuation">(</span><span class="token constant">ILOAD</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">//调用接口中的抽象方法println</span></span>
<span class="line">v2<span class="token punctuation">.</span><span class="token function">visitMethodInsn</span><span class="token punctuation">(</span><span class="token constant">INVOKEVIRTUAL</span><span class="token punctuation">,</span> <span class="token string">&quot;java/io/PrintStream&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;println&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;(I)V&quot;</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">//再次记录行信息</span></span>
<span class="line"><span class="token class-name">Label</span> l6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Label</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">v2<span class="token punctuation">.</span><span class="token function">visitLabel</span><span class="token punctuation">(</span>l6<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">v2<span class="token punctuation">.</span><span class="token function">visitLineNumber</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> l6<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">v2<span class="token punctuation">.</span><span class="token function">visitInsn</span><span class="token punctuation">(</span><span class="token constant">RETURN</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">Label</span> l7 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Label</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">v2<span class="token punctuation">.</span><span class="token function">visitLabel</span><span class="token punctuation">(</span>l7<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">//最后是本地变量表中的各个变量</span></span>
<span class="line">v2<span class="token punctuation">.</span><span class="token function">visitLocalVariable</span><span class="token punctuation">(</span><span class="token string">&quot;args&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;[Ljava/lang/String;&quot;</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> l3<span class="token punctuation">,</span> l7<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">v2<span class="token punctuation">.</span><span class="token function">visitLocalVariable</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;I&quot;</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> l4<span class="token punctuation">,</span> l7<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">v2<span class="token punctuation">.</span><span class="token function">visitMaxs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">//终于OK了</span></span>
<span class="line">v2<span class="token punctuation">.</span><span class="token function">visitEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，虽然很简单的一个程序，但是如果我们手动去编写字节码，实际上是非常麻烦的，但是要实现动态代理之类的操作（可以很方便地修改字节码创建子类），是不是感觉又 Get 到了新操作（其实 Spring 实现动态代理的 CGLib 框架底层正是调用了 ASM 框架来实现的），所以说了解一下还是可以的，不过我们自己肯定是没多少玩这个的机会了。</p><hr><h2 id="类加载机制" tabindex="-1"><a class="header-anchor" href="#类加载机制"><span>类加载机制</span></a></h2><p>现在，我们已经了解了字节码文件的结构，以及 JVM 如何对内存进行管理，现在只剩下最后一个谜团等待解开了，也就是我们的类字节码文件到底是如何加载到内存中的，加载之后又会做什么事情。</p><h3 id="类加载过程" tabindex="-1"><a class="header-anchor" href="#类加载过程"><span>类加载过程</span></a></h3><p>首先，要加载一个类，一定是出于某种目的的，比如我们要运行我们的 Java 程序，那么就必须要加载主类才能运行主类中的主方法，又或是我们需要加载数据库驱动，那么可以通过反射来将对应的数据库驱动类进行加载。</p><p>所以，一般在这些情况下，如果类没有被加载，那么会被自动加载：</p><ul><li>使用 new 关键字创建对象时</li><li>使用某个类的静态成员（包括方法和字段）的时候（当然，final 类型的静态字段有可能在编译的时候被放到了当前类的常量池中，这种情况下是不会触发自动加载的）</li><li>使用反射对类信息进行获取的时候（之前的数据库驱动就是这样的）</li><li>加载一个类的子类时</li><li>加载接口的实现类，且接口带有<code>default</code>的方法默认实现时</li></ul><p>比如这种情况，那么需要用到另一个类中的成员字段，所以就必须将另一个类加载之后才能访问：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Test</span><span class="token punctuation">.</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">static</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我被初始化了！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">&quot;都看到这里了，不给个三连+关注吗？&quot;</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们就演示一个不太好理解的情况，我们现在将静态成员变量修改为 final 类型的：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Test</span><span class="token punctuation">.</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">static</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我被初始化了！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">&quot;都看到这里了，不给个三连+关注吗？&quot;</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，在主方法中，我们使用了 Test 类的静态成员变量，并且此静态成员变量是一个 final 类型的，也就是说不可能再发生改变。那么各位觉得，Test 类会像上面一样被初始化吗？</p><p>按照正常逻辑来说，既然要用到其他类中的字段，那么肯定需要加载其他类，但是这里我们结果发现，并没有对 Test 类进行加载，那么这是为什么呢？我们来看看 Main 类编译之后的字节码指令就知道了：</p><figure><img src="`+B+'" alt="image-20230306170622970" tabindex="0" loading="lazy"><figcaption>image-20230306170622970</figcaption></figure><p>很明显，这里使用的是<code>ldc</code>指令从常量池中将字符串取出并推向操作数栈顶，也就是说，在编译阶段，整个<code>Test.str</code>直接被替换为了对应的字符串（因为 final 不可能发生改变的，编译就会进行优化，直接来个字符串比你去加载类在获取快得多不是吗，反正结果都一样），所以说编译之后，实际上跟 Test 类半毛钱关系都没有了。</p><p>所以说，当你在某些情况下疑惑为什么类加载了或是没有加载时，可以从字节码指令的角度去进行分析，一般情况下，只要遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code>这些指令时，都会进行类加载，比如：</p><figure><img src="'+I+'" alt="image-20230306170635704" tabindex="0" loading="lazy"><figcaption>image-20230306170635704</figcaption></figure><p>这里很明显，是一定会将 Test 类进行加载的。除此之外，各位也可以试试看数组的定义会不会导致类被加载。</p><p>好了，聊完了类的加载触发条件，我们接着来看一下类的详细加载流程。</p><figure><img src="'+O+`" alt="image-20230306170654350" tabindex="0" loading="lazy"><figcaption>image-20230306170654350</figcaption></figure><p>首先类的生命周期一共有 7 个阶段，而首当其冲的就是加载，加载阶段需要获取此类的二进制数据流，比如我们要从硬盘中读取一个 class 文件，那么就可以通过文件输入流来获取类文件的<code>byte[]</code>，也可以是其他各种途径获取类文件的输入流，甚至网络传输并加载一个类也不是不可以。然后交给类加载器进行加载（类加载器可以是 JDK 内置的，也可以是开发者自己撸的，后面会详细介绍）类的所有信息会被加载到方法区中，并且在堆内存中会生成一个代表当前类的 Class 类对象（那么思考一下，同一个 Class 文件加载的类，是唯一存在的吗？），我们可以通过此对象以及反射机制来访问这个类的各种信息。</p><p>数组类要稍微特殊一点，通过前面的检验，我没发现数组在创建后是不会导致类加载的，数组类型本身不会通过类加载器进行加载的，不过你既然要往里面丢对象进去，那最终依然是要加载类的。</p><p>接着我们来看验证阶段，验证阶段相当于是对加载的类进行一次规范校验（因为一个类并不一定是由我们使用 IDEA 编译出来的，有可能是像我们之前那样直接用 ASM 框架写的一个），如果说类的任何地方不符合虚拟机规范，那么这个类是不会验证通过的，如果没有验证机制，那么一旦出现危害虚拟机的操作，整个程序会出现无法预料的后果。</p><p>验证阶段，首先是文件格式的验证：</p><ul><li>是否魔数为 CAFEBABE 开头。</li><li>主、次版本号是否可以由当前 Java 虚拟机运行</li><li>Class 文件各个部分的完整性如何。</li><li>...</li></ul><p>有关类验证的详细过程，可以参考《深入理解 Java 虚拟机 第三版》268 页。</p><p>接下来就是准备阶段了，这个阶段会为类变量分配内存，并为一些字段设定初始值，注意是系统规定的初始值，不是我们手动指定的初始值。</p><p>再往下就是解析阶段，此阶段是将常量池内的符号引用替换为直接引用的过程，也就是说，到这个时候，所有引用变量的指向都是已经切切实实地指向了内存中的对象了。</p><p>到这里，链接过程就结束了，也就是说这个时候类基本上已经完成大部分内容的初始化了。</p><p>最后就是真正的初始化阶段了，从这里开始，类中的 Java 代码部分，才会开始执行，还记得我们之前介绍的<code>&lt;clinit&gt;</code>方法吗，它就是在这个时候执行的，比如我们的类中存在一个静态成员变量，并且赋值为 10，或是存在一个静态代码块，那么就会自动生成一个<code>&lt;clinit&gt;</code>方法来进行赋值操作，但是这个方法是自动生成的。</p><p>全部完成之后，我们的类就算是加载完成了。</p><hr><h3 id="类加载器" tabindex="-1"><a class="header-anchor" href="#类加载器"><span>类加载器</span></a></h3><p>Java 提供了类加载器，以便我们自己可以更好地控制类加载，我们可以自定义类加载器，也可以使用官方自带的类加载器去加载类。对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在 Java 虚拟机中的唯一性。</p><p>也就是说，一个类可以由不同的类加载器加载，并且，不同的类加载器加载的出来的类，即使来自同一个 Class 文件，也是不同的，只有两个类来自同一个 Class 文件并且是由同一个类加载器加载的，才能判断为是同一个。默认情况下，所有的类都是由 JDK 自带的类加载器进行加载。</p><p>比如，我们先创建一个 Test 类用于测试：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>test</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着我们自己实现一个 ClassLoader 来加载我们的 Test 类，同时使用官方默认的类加载器来加载：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ReflectiveOperationException</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> testClass1 <span class="token operator">=</span> <span class="token class-name">Main</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">&quot;com.test.Test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token class-name">CustomClassLoader</span> customClassLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> testClass2 <span class="token operator">=</span> customClassLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">&quot;com.test.Test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">//看看两个类的类加载器是不是同一个</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>testClass1<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>testClass2<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">       <span class="token comment">//看看两个类是不是长得一模一样</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>testClass1<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>testClass2<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">       <span class="token comment">//两个类是同一个吗？</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>testClass1 <span class="token operator">==</span> testClass2<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">       <span class="token comment">//能成功实现类型转换吗？</span></span>
<span class="line">        <span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Test</span><span class="token punctuation">)</span> testClass2<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CustomClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token annotation punctuation">@Override</span></span>
<span class="line">        <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">FileInputStream</span> stream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">&quot;./target/classes/&quot;</span><span class="token operator">+</span>name<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">&quot;.&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">&quot;.class&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">                <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>stream<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">                stream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                <span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过结果我们发现，即使两个类是同一个 Class 文件加载的，只要类加载器不同，那么这两个类就是不同的两个类。</p><p>所以说，我们当时在 JavaSE 阶段讲解的每个类都在堆中有一个唯一的 Class 对象放在这里来看，并不完全正确，只是当前为了防止各位初学者搞混。</p><p>实际上，JDK 内部提供的类加载器一共有三个，比如上面我们的 Main 类，其实是被 AppClassLoader 加载的，而 JDK 内部的类，都是由 BootstrapClassLoader 加载的，这其实就是为了实现双亲委派机制而做的。</p><figure><img src="`+N+'" alt="image-20230306170728531" tabindex="0" loading="lazy"><figcaption>image-20230306170728531</figcaption></figure><p>有关双亲委派机制，我们在 JavaSE 阶段反射板块已经讲解过了，所以说这就不多做介绍了。</p>',190)]))}const F=s(E,[["render",U]]),W=JSON.parse('{"path":"/codenotes/java/jvm/%E7%B1%BB%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD.html","title":"Java JVM 虚拟机 - 类与类加载","lang":"zh-CN","frontmatter":{"title":"Java JVM 虚拟机 - 类与类加载","icon":"JVM","category":["Java","JVM"],"tag":["JVM"],"sticky":false,"star":false,"article":false,"order":3,"timeline":false,"description":"前面我们讲解了 JVM 的内存结构，包括 JVM 如何对内存进行划分，如何对内存区域进行垃圾回收。接下来，我们来研究一下类文件结构以及类的加载机制。 类文件结构 在我们学习 C 语言的时候，我们的编程过程会经历如下几个阶段：写代码、保存、编译、运行。实际上，最关键的一步是编译，因为只有经历了编译之后，我们所编写的代码才能够翻译为机器可以直接运行的二进制...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"Java JVM 虚拟机 - 类与类加载\\",\\"description\\":\\"前面我们讲解了 JVM 的内存结构，包括 JVM 如何对内存进行划分，如何对内存区域进行垃圾回收。接下来，我们来研究一下类文件结构以及类的加载机制。 类文件结构 在我们学习 C 语言的时候，我们的编程过程会经历如下几个阶段：写代码、保存、编译、运行。实际上，最关键的一步是编译，因为只有经历了编译之后，我们所编写的代码才能够翻译为机器可以直接运行的二进制...\\"}"],["meta",{"property":"og:url","content":"https://www.stazxr.cn/my-notes/my-notes/codenotes/java/jvm/%E7%B1%BB%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD.html"}],["meta",{"property":"og:site_name","content":"終わり群星の知识宝库"}],["meta",{"property":"og:title","content":"Java JVM 虚拟机 - 类与类加载"}],["meta",{"property":"og:description","content":"前面我们讲解了 JVM 的内存结构，包括 JVM 如何对内存进行划分，如何对内存区域进行垃圾回收。接下来，我们来研究一下类文件结构以及类的加载机制。 类文件结构 在我们学习 C 语言的时候，我们的编程过程会经历如下几个阶段：写代码、保存、编译、运行。实际上，最关键的一步是编译，因为只有经历了编译之后，我们所编写的代码才能够翻译为机器可以直接运行的二进制..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-06T16:19:30.000Z"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:modified_time","content":"2025-06-06T16:19:30.000Z"}]]},"git":{"createdTime":1749218848000,"updatedTime":1749226770000,"contributors":[{"name":"talentestors","username":"talentestors","email":"talentestors@gmail.com","commits":2,"url":"https://github.com/talentestors"}]},"readingTime":{"minutes":29.79,"words":8936},"filePathRelative":"codenotes/java/jvm/类与类加载.md","autoDesc":true}');export{F as comp,W as data};
